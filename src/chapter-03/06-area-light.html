<!DOCTYPE html>

<html>

// TODO: Change to this: http://jsfiddle.net/hh74z2ft/30/

<head>
    <title>Example 03.06 - Area Light</title>
    <script type="text/javascript" charset="UTF-8" src="../../libs/three/three.js"></script>
    <script type="text/javascript" charset="UTF-8" src="../../libs/three/controls/TrackballControls.js"></script>
    <script type="text/javascript" src="../../libs/util/Stats.js"></script>
    <script type="text/javascript" src="../../libs/util/dat.gui.js"></script>

    <script type="text/javascript" src="../js/util.js"></script>
    <script type="text/javascript" src="./js/03-06.js"></script>
    <link rel="stylesheet" href="../../css/default.css">
</head>

<body>
    <div id="webgl-output">
        <script type="text/javascript">
            (function () {
                // your page initialization code here
                // the DOM will be available here
                init()
            })();
        </script>
</body>

</html>
<script id="vertex_shader" type="x-shader/x-vertex">

    #define NVERTS 4 varying vec3 vNormal; varying vec3 vViewPosition; void main() { vec4 mvPosition = modelViewMatrix * vec4(
    position, 1.0 ); vNormal = normalize( normalMatrix * normal ); vViewPosition = -mvPosition.xyz; gl_Position = projectionMatrix
    * modelViewMatrix * vec4( position, 1.0 ); }

</script>

<script id="fragment_shader" type="x-shader/x-fragment">

    #define NVERTS 4 uniform vec3 color; uniform vec3 lightColor; uniform float lightIntensity; uniform vec3 lightverts[ NVERTS
    ]; // in local space uniform mat4 lightMatrixWorld; varying vec3 vNormal; // in camera space varying vec3 vViewPosition;
    // in camera space void main() { vec3 normal = normalize( vNormal ); vec4 lPosition[ NVERTS ]; vec3 lVector[ NVERTS ];
    // stub in some ambient reflectance vec3 ambient = color * vec3( 0.2 ); // direction vectors from point to area light
    corners for( int i = 0; i
    < NVERTS; i ++ ) { lPosition[ i ]=v iewMatrix * lightMatrixWorld * vec4( lightverts[ i ], 1.0 ); // in camera space lVector[
        i ]=n ormalize( lPosition[ i ].xyz + vViewPosition.xyz ); // dir from vertex to areaLight } // bail if the point is on
        the wrong side of the light... there must be a better way... float tmp=d ot( lVector[ 0 ], cross( ( lPosition[ 2 ] -
        lPosition[ 0 ] ).xyz, ( lPosition[ 1 ] - lPosition[ 0 ] ).xyz ) ); if ( tmp> 0.0 ) { gl_FragColor = vec4( ambient, 1.0 ); return; } // vector irradiance at point vec3 lightVec = vec3( 0.0 ); for(
        int i = 0; i
        < NVERTS; i ++ ) { vec3 v0=l Vector[ i ]; vec3 v1=l Vector[ int( mod( float( i + 1 ), float( NVERTS ) ) ) ]; // ugh... lightVec
            +=a cos( dot( v0, v1 ) ) * normalize( cross( v0, v1 ) ); } // irradiance factor at point float factor=m ax( dot(
            lightVec, normal ), 0.0 ) / ( 2.0 * 3.14159265 ); // frag color vec3 diffuse=c olor * lightColor * lightIntensity
            * factor; gl_FragColor=v ec4( ambient + diffuse, 1.0 ); } </script>

            <div id="Stats-output">
            </div>
            <!-- Div which will hold the Output -->
            <div id="WebGL-output">
            </div>

            <!-- Javascript code that runs our Three.js examples -->
            <script type="text/javascript">
                var camera;

                // once everything is loaded, we run our Three.js stuff.
                function init() {

                    var stats = initStats();

                    // create a scene, that will hold all our elements such as objects, cameras and lights.
                    var scene = new THREE.Scene();

                    // create a camera, which defines where we're looking at.
                    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                    scene.add(camera);

                    // create a render and set the size
                    var renderer = new THREE.WebGLRenderer();
                    renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    // create the ground plane
                    var planeGeometry = new THREE.PlaneGeometry(70, 70, 1, 1);
                    var planeMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        specular: 0xffffff,
                        shininess: 200
                    });
                    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
                    // plane.receiveShadow  = true;

                    // rotate and position the plane
                    plane.rotation.x = -0.5 * Math.PI;
                    plane.position.x = 0;
                    plane.position.y = 0;
                    plane.position.z = 0;

                    // add the plane to the scene
                    scene.add(plane);

                    // position and point the camera to the center of the scene
                    camera.position.x = 20;
                    camera.position.y = 30;
                    camera.position.z = 21;
                    camera.lookAt(new THREE.Vector3(0, 0, -30));

                    // add the output of the renderer to the html element
                    document.getElementById("WebGL-output").appendChild(renderer.domElement);

                    // call the render function
                    var step = 0;


                    var spotLight0 = new THREE.SpotLight(0xcccccc);
                    spotLight0.position.set(-40, 60, -10);
                    spotLight0.intensity = 0.1;
                    spotLight0.lookAt(plane);
                    scene.add(spotLight0);


                    // uniforms
                    var uniforms = {
                        color: {
                            type: "c",
                            value: new THREE.Color(0xaaaadd)
                        },

                        lightColor: {
                            type: "c",
                            value: areaLight.material.color
                        },
                        lightIntensity: {
                            type: "f",
                            value: lightIntensity
                        },
                        lightverts: {
                            type: "v3v",
                            value: verts
                        },
                        lightMatrixWorld: {
                            type: "m4",
                            value: areaLight.matrixWorld
                        }
                    };

                    // material
                    material = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: document.getElementById('vertex_shader').textContent,
                        fragmentShader: document.getElementById('fragment_shader').textContent,
                        shading: THREE.SmoothShading
                    });


                    var areaLight1 = new THREE.AreaLight(0xff0000, 3);
                    areaLight1.position.set(-10, 10, -35);
                    areaLight1.rotation.set(-Math.PI / 2, 0, 0);
                    areaLight1.width = 4;
                    areaLight1.height = 9.9;
                    scene.add(areaLight1);

                    var areaLight2 = new THREE.AreaLight(0x00ff00, 3);
                    areaLight2.position.set(0, 10, -35);
                    areaLight2.rotation.set(-Math.PI / 2, 0, 0);
                    areaLight2.width = 4;
                    areaLight2.height = 9.9;
                    scene.add(areaLight2);

                    var areaLight3 = new THREE.AreaLight(0x0000ff, 3);
                    areaLight3.position.set(10, 10, -35);
                    areaLight3.rotation.set(-Math.PI / 2, 0, 0);
                    areaLight3.width = 4;
                    areaLight3.height = 9.9;
                    scene.add(areaLight3);

                    var planeGeometry1 = new THREE.BoxGeometry(4, 10, 0);
                    var planeGeometry1Mat = new THREE.MeshBasicMaterial({
                        color: 0xff0000
                    });
                    var plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat);
                    plane1.position.copy(areaLight1.position);
                    scene.add(plane1);


                    var planeGeometry2 = new THREE.BoxGeometry(4, 10, 0);
                    var planeGeometry2Mat = new THREE.MeshBasicMaterial({
                        color: 0x00ff00
                    });
                    var plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat);

                    plane2.position.copy(areaLight2.position);
                    scene.add(plane2);

                    var planeGeometry3 = new THREE.BoxGeometry(4, 10, 0);
                    var planeGeometry3Mat = new THREE.MeshBasicMaterial({
                        color: 0x0000ff
                    });
                    var plane3 = new THREE.Mesh(planeGeometry3, planeGeometry3Mat);

                    plane3.position.copy(areaLight3.position);
                    scene.add(plane3);


                    var controls = new function () {
                        this.rotationSpeed = 0.02;
                        this.color1 = 0xff0000;
                        this.intensity1 = 2;
                        this.color2 = 0x00ff00;
                        this.intensity2 = 2;
                        this.color3 = 0x0000ff;
                        this.intensity3 = 2;
                    };

                    var gui = new dat.GUI();
                    gui.addColor(controls, 'color1').onChange(function (e) {
                        areaLight1.color = new THREE.Color(e);
                        planeGeometry1Mat.color = new THREE.Color(e);
                        scene.remove(plane1);
                        plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat);
                        plane1.position.copy(areaLight1.position);
                        scene.add(plane1);

                    });
                    gui.add(controls, 'intensity1', 0, 5).onChange(function (e) {
                        areaLight1.intensity = e;
                    });
                    gui.addColor(controls, 'color2').onChange(function (e) {
                        areaLight2.color = new THREE.Color(e);
                        planeGeometry2Mat.color = new THREE.Color(e);
                        scene.remove(plane2);
                        plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat);
                        plane2.position.copy(areaLight2.position);
                        scene.add(plane2);
                    });
                    gui.add(controls, 'intensity2', 0, 5).onChange(function (e) {
                        areaLight2.intensity = e;
                    });
                    gui.addColor(controls, 'color3').onChange(function (e) {
                        areaLight3.color = new THREE.Color(e);
                        planeGeometry3Mat.color = new THREE.Color(e);
                        scene.remove(plane3);
                        plane3 = new THREE.Mesh(planeGeometry1, planeGeometry3Mat);
                        plane3.position.copy(areaLight3.position);
                        scene.add(plane3);
                    });
                    gui.add(controls, 'intensity3', 0, 5).onChange(function (e) {
                        areaLight3.intensity = e;
                    });


                    render();

                    function render() {
                        stats.update();

                        // render using requestAnimationFrame
                        requestAnimationFrame(render);
                        renderer.render(scene, camera);
                    }

                    function initStats() {

                        var stats = new Stats();

                        stats.setMode(0); // 0: fps, 1: ms

                        // Align top-left
                        stats.domElement.style.position = 'absolute';
                        stats.domElement.style.left = '0px';
                        stats.domElement.style.top = '0px';

                        document.getElementById("Stats-output").appendChild(stats.domElement);

                        return stats;
                    }
                }
                window.onload = init;
            </script>
            </body>

            </html>